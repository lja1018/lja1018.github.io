---
title:  "개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 Ch.2"
excerpt: "개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 Ch.2 정리"

categories:
  - 베이스캠프
tags:
  - 베이스캠프
  - 스터디
  - 정리
---
# 객체 지향과 패턴 Ch.2

## 객체 지향

### 1. 절차 지향과 객체 지향
#### 절차지향(Procedural Oriented) 
* `프로시저(Procedure)`로 프로그램을 구성하는 기법
* 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 프로시저가 증가
* 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생
* 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는데 많은 구현 시간(비용)을 투입하게 만든다.

#### 객체지향(Objecct Oriented)
* `객체(Object)`로 구성이 되며, 자신만의 데이터와 프로시저를 갖는다.
* 각 객체는 자신만의 기능을 제공하며, 서로 연결되어 다른 객체가 제공하는 기능을 사용 할 수 있게된다.

### 2. 객체(Object)
#### 1) 객체의 핵심은 기능을 제공하는 것
* 객체가 내부적으로 어떤 데이터 타입 값으로 보관하는지는 중요하지 않다.
* 어떤 기능을 제공한다는 것이 중요할 뿐이다.

#### 2) 인터페이스와 클래스
* 보통 객체가 제공하는 기능을 오퍼레이션(Operation)라고 부른다. 즉, 객체는 오퍼레이션으로 정의가 된다.
* 오퍼레이션의 사용법은 다음 3가지로 구성되며, 이 3가지를 합쳐 `시그니처(Signature)`라고 부른다.
  * 기능 식별 이름
  * 파라미터 및 파라미터 타입
  * 기능 실행 결과 값
* 객체가 제공하는 모든 오퍼레이션 집합을 객체의 `인터페이스(Interface)`라고 부르며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 `타입(Type)`이다.
* 인터페이스 객체는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는 지에 대한 내용은 포함하고 있지 않다.

#### 3) 메시지
* 오퍼레이션의 실행을 요청(Request)하는 것을 \``메시지(Message)`를 보낸다'고 표현한다.

### 3. 객체의 책임과 크기
* 상황에 따라 객체가 가져야 할 기능의 종류와 개수가 달라지기 때문에, 모든 상황에 들어맞는 객체-책임 구성 규칙이 존재하는 것은 아니다.
* 확실한 규칙 하나는, `객체가 갖는 책임의 크기는 작을수록 좋다`는 것이다.
  * 한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게 되기 때문이다.
  * 객체가 갖는 책임의 크기가 작아질수록 객체 지향의 장점인 `변경의 유연함`을 얻을 수 있게 된다.
* 단일 책임 원칙(Single Responsibility Principle:SRP) : 객체는 단 하나의 책임만을 가져야 한다는 원칙

### 4. 의존
* 한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 `의존(Dependency)`한다고 표현한다.
* 객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받든 다른 타입에 의존을 한다는 것은 의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것을 뜻한다.
* A클래스 <- B클래스 <- C클래스 <- A클래스 같이 의존이 순환해서 발생할 경우(`순환 의존`) 적극적으로 이를 해소하는 방법을 찾아야 한다.
* 순환 의존이 발생하지 않도록 하는 원칙 중의 하나로 ```의존 역전 원칙(Dependency inversion principle: DIP) 가 있다.(Ch.5)

#### 의존의 양면성
* 내가 변경되면 나에게 의존하고 있는 코드에 영향을 준다.
* 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 준다.

### 5. 캡슐화
* `캡슐화(encapsulation)`는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다.

#### 1. 절차지향 방식의 경우
* 규칙이 변경되면 코드에 반영해야하고 이미 여러 곳에서 사용되는 중이기 때문에, 그 코드들을 모두 찾아서 변경해 주어야 한다.
* 이는 데이터를 중심으로 프로그래밍했기 때문이다. 즉 절차 지향적으로 만들었기 때문이다.
* 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에, 요구 사항의 변화로 인해 데이터의 구조나 쓰임새가 변경되면 이로 인해 데이터를 사용하는 코드들도 연쇄적으로 수정해 주어야 한다.

#### 2. 캡슐화 된 기능 구현
* 캡슐화는 변경의 여파를 최소화한다.

#### 3. 캡슐화의 결과는 내부 구현 변경의 유연성 획득

#### 4. 캡슐화를 위한 2개의 규칙
* Tell, Don't Ask
  * 데이터를 물어보지 않고, 기능을 실행해 달라고 말하는 규칙
  * 데이터를 읽는 것은 데이터를 중심으로 코드를 작성하게 만드는 원인이 되며, 따라서 절차 지향적인 코드를 유도하게 된다.
* 데미테르의 법칙(Law of Demeter)
  * 메서드에서 생성한 객체의 메서드만 호출
  * 파라미터로 받은 객체의 메서드만 호출
  * 필드로 참조하는 객체의 메서드만 호출
* 데미테르의 법칙을 지키지 않는 전형적인 증상 2가지
  * 연속된 get 메서드 호출
    ```
    value = someObject.getA().getB().getValue();
    ```
  * 임시 변수의 get 호출이 많음
    ```
    A a = someObject.getA();
    B b = a.getB();
    value = b.getValue();
    ```
    * 사실상 첫 번째 증상과 동일하지만, 코드가 흩어져 있을 경우 발견하기 어려울 수 있다.

### 6. 객체 지향 설계 과정
* 제공해야 할 기능을 찾고(또는 세분화), 그 기능을 알맞은 객체에 할당.
  * 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.
  * 기능은 최대한 캡슐화해서 구현한다.
* 객체 간에 어떻게 메시지를 주고받을 지 결정한다.
* 1과 2를 개발하는 동안 지속적으로 반복한다.